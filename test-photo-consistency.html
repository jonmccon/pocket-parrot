<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Data Consistency Test - Pocket Parrot</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .test-section {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        .test-section.running {
            border-left-color: #FF9800;
        }
        .test-section.failed {
            border-left-color: #F44336;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        input, select, button {
            padding: 10px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }
        input, select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            flex: 1;
            min-width: 200px;
        }
        button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .button-warning {
            background: #FF9800;
        }
        .button-warning:hover {
            background: #F57C00;
        }
        .button-danger {
            background: #F44336;
        }
        .button-danger:hover {
            background: #D32F2F;
        }
        .results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
        }
        .results pre {
            margin: 0;
            white-space: pre-wrap;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        .status.success {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4CAF50;
        }
        .status.warning {
            background: rgba(255, 152, 0, 0.3);
            border: 1px solid #FF9800;
        }
        .status.error {
            background: rgba(244, 67, 54, 0.3);
            border: 1px solid #F44336;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        .photo-test {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .photo-preview {
            max-width: 200px;
            max-height: 150px;
            border: 2px solid #444;
            border-radius: 4px;
            margin: 10px;
        }
        .progress {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress-bar {
            background: #4CAF50;
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧪 Photo Data Consistency Test Suite</h1>
        
        <div class="test-section">
            <h2>📡 Server Connection Test</h2>
            <div class="controls">
                <input type="text" id="serverUrl" placeholder="ws://localhost:8080/listener" value="ws://localhost:8080/listener">
                <button id="connectBtn" onclick="testConnection()">Test Connection</button>
                <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
            </div>
            <div id="connectionStatus" class="status warning">
                ⚫ Not connected - Click "Test Connection" to begin
            </div>
        </div>

        <div class="test-section">
            <h2>📸 Photo Generation Test</h2>
            <div class="controls">
                <select id="photoSize">
                    <option value="small">Small (400x300)</option>
                    <option value="medium" selected>Medium (800x600)</option>
                    <option value="large">Large (1200x900)</option>
                </select>
                <select id="photoQuality">
                    <option value="0.5">Low Quality (0.5)</option>
                    <option value="0.7" selected>Medium Quality (0.7)</option>
                    <option value="0.9">High Quality (0.9)</option>
                </select>
                <button onclick="generateTestPhoto()">Generate Test Photo</button>
                <button onclick="runPhotoConsistencyTest()" class="button-warning">Run Consistency Test</button>
            </div>
            <div class="grid">
                <div class="metric">
                    <div class="metric-value" id="photosGenerated">0</div>
                    <div class="metric-label">Photos Generated</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="photosTransmitted">0</div>
                    <div class="metric-label">Photos Transmitted</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="successRate">0%</div>
                    <div class="metric-label">Success Rate</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="avgSize">0KB</div>
                    <div class="metric-label">Average Size</div>
                </div>
            </div>
            <div class="photo-test">
                <h4>Latest Generated Photo:</h4>
                <canvas id="testCanvas" width="200" height="150" style="border: 2px solid #444; border-radius: 4px;"></canvas>
                <div id="photoDetails">No photo generated yet</div>
            </div>
        </div>

        <div class="test-section">
            <h2>🔄 Live Data Stream Test</h2>
            <div class="controls">
                <input type="number" id="testDuration" value="30" min="10" max="300" placeholder="Test duration (seconds)">
                <select id="testInterval">
                    <option value="1000">1 second</option>
                    <option value="2000">2 seconds</option>
                    <option value="5000" selected>5 seconds</option>
                    <option value="10000">10 seconds</option>
                </select>
                <button id="startStreamTest" onclick="startStreamTest()" class="button-warning">Start Stream Test</button>
                <button id="stopStreamTest" onclick="stopStreamTest()" disabled class="button-danger">Stop Test</button>
            </div>
            <div class="progress">
                <div class="progress-bar" id="testProgress" style="width: 0%"></div>
            </div>
            <div id="streamStatus" class="status warning">
                Stream test not started
            </div>
        </div>

        <div class="test-section">
            <h2>📊 Real-time Statistics</h2>
            <div class="grid">
                <div class="metric">
                    <div class="metric-value" id="totalReceived">0</div>
                    <div class="metric-label">Total Messages</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="withPhotos">0</div>
                    <div class="metric-label">With Photos</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="dataErrors">0</div>
                    <div class="metric-label">Data Errors</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="avgLatency">0ms</div>
                    <div class="metric-label">Avg Latency</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>📋 Test Results Log</h2>
            <button style="float: right; margin-bottom: 10px;" onclick="clearResults()">Clear Log</button>
            <div id="testResults" class="results">
                <pre>Test results will appear here...\n</pre>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let testStats = {
            photosGenerated: 0,
            photosTransmitted: 0,
            totalReceived: 0,
            withPhotos: 0,
            dataErrors: 0,
            latencies: [],
            photoSizes: []
        };
        let streamTestInterval = null;
        let streamTestTimeout = null;
        let testStartTime = null;

        function log(message, type = 'info') {
            const results = document.getElementById('testResults');
            const timestamp = new Date().toISOString();
            const prefix = type === 'error' ? '❌' : type === 'warn' ? '⚠️' : type === 'success' ? '✅' : 'ℹ️';
            results.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            results.scrollTop = results.scrollHeight;
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
        }

        function updateStats() {
            document.getElementById('photosGenerated').textContent = testStats.photosGenerated;
            document.getElementById('photosTransmitted').textContent = testStats.photosTransmitted;
            document.getElementById('totalReceived').textContent = testStats.totalReceived;
            document.getElementById('withPhotos').textContent = testStats.withPhotos;
            document.getElementById('dataErrors').textContent = testStats.dataErrors;
            
            const successRate = testStats.photosGenerated > 0 
                ? Math.round((testStats.photosTransmitted / testStats.photosGenerated) * 100)
                : 0;
            document.getElementById('successRate').textContent = successRate + '%';
            
            const avgSize = testStats.photoSizes.length > 0
                ? Math.round(testStats.photoSizes.reduce((a, b) => a + b, 0) / testStats.photoSizes.length / 1024)
                : 0;
            document.getElementById('avgSize').textContent = avgSize + 'KB';
            
            const avgLatency = testStats.latencies.length > 0
                ? Math.round(testStats.latencies.reduce((a, b) => a + b, 0) / testStats.latencies.length)
                : 0;
            document.getElementById('avgLatency').textContent = avgLatency + 'ms';
        }

        function testConnection() {
            const url = document.getElementById('serverUrl').value;
            if (!url) {
                log('Please enter a server URL', 'error');
                return;
            }

            try {
                ws = new WebSocket(url);
                
                ws.onopen = () => {
                    log(`✅ Connected to ${url}`, 'success');
                    document.getElementById('connectionStatus').className = 'status success';
                    document.getElementById('connectionStatus').textContent = '🟢 Connected and ready for testing';
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                };

                ws.onmessage = (event) => {
                    const receiveTime = Date.now();
                    try {
                        const data = JSON.parse(event.data);
                        analyzeReceivedData(data, receiveTime);
                        updateStats();
                    } catch (error) {
                        testStats.dataErrors++;
                        log(`❌ Failed to parse message: ${error.message}`, 'error');
                        updateStats();
                    }
                };

                ws.onclose = () => {
                    log('Connection closed', 'warn');
                    document.getElementById('connectionStatus').className = 'status warning';
                    document.getElementById('connectionStatus').textContent = '⚫ Disconnected';
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                };

                ws.onerror = (error) => {
                    log(`Connection error: ${error}`, 'error');
                    document.getElementById('connectionStatus').className = 'status error';
                    document.getElementById('connectionStatus').textContent = '❌ Connection failed';
                };

            } catch (error) {
                log(`Failed to connect: ${error.message}`, 'error');
            }
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function generateTestPhoto() {
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');
            const size = document.getElementById('photoSize').value;
            const quality = parseFloat(document.getElementById('photoQuality').value);
            
            // Set canvas dimensions based on size selection
            const dimensions = {
                small: [400, 300],
                medium: [800, 600],
                large: [1200, 900]
            };
            
            const [width, height] = dimensions[size];
            canvas.width = width;
            canvas.height = height;
            
            // Generate a colorful test pattern
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, `hsl(${Math.random() * 360}, 70%, 50%)`);
            gradient.addColorStop(0.5, `hsl(${Math.random() * 360}, 70%, 50%)`);
            gradient.addColorStop(1, `hsl(${Math.random() * 360}, 70%, 50%)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Add some test patterns
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.fillText(`Test ${testStats.photosGenerated + 1}`, 50, 100);
            ctx.fillText(`${new Date().toLocaleTimeString()}`, 50, 160);
            
            // Add geometric shapes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 50 + 10;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Convert to blob and simulate processing
            canvas.toBlob((blob) => {
                testStats.photosGenerated++;
                const photoSize = blob.size;
                
                // Update display canvas to show smaller version
                const displayCanvas = document.getElementById('testCanvas');
                displayCanvas.width = 200;
                displayCanvas.height = 150;
                const displayCtx = displayCanvas.getContext('2d');
                displayCtx.drawImage(canvas, 0, 0, 200, 150);
                
                document.getElementById('photoDetails').innerHTML = `
                    <strong>Size:</strong> ${Math.round(photoSize / 1024)}KB<br>
                    <strong>Dimensions:</strong> ${width}x${height}<br>
                    <strong>Quality:</strong> ${quality}<br>
                    <strong>Generated:</strong> ${new Date().toLocaleTimeString()}
                `;
                
                log(`📸 Generated test photo: ${Math.round(photoSize / 1024)}KB (${width}x${height})`, 'success');
                updateStats();
                
                // Simulate transmission (this would normally go through your app's data pipeline)
                simulatePhotoTransmission(blob);
                
            }, 'image/jpeg', quality);
        }

        function simulatePhotoTransmission(photoBlob) {
            // This simulates the photo going through your app's data pipeline
            testStats.photosTransmitted++;
            testStats.photoSizes.push(photoBlob.size);
            
            log(`📤 Simulated photo transmission: ${Math.round(photoBlob.size / 1024)}KB`, 'info');
            updateStats();
        }

        function runPhotoConsistencyTest() {
            log('🧪 Starting photo consistency test...', 'info');
            
            // Generate 5 photos of different sizes and qualities
            const tests = [
                { size: 'small', quality: 0.5 },
                { size: 'medium', quality: 0.7 },
                { size: 'large', quality: 0.9 },
                { size: 'medium', quality: 0.5 },
                { size: 'small', quality: 0.9 }
            ];
            
            tests.forEach((test, index) => {
                setTimeout(() => {
                    document.getElementById('photoSize').value = test.size;
                    document.getElementById('photoQuality').value = test.quality;
                    generateTestPhoto();
                }, index * 1000);
            });
            
            log(`🔄 Running ${tests.length} photo generation tests...`, 'info');
        }

        function startStreamTest() {
            const duration = parseInt(document.getElementById('testDuration').value) * 1000;
            const interval = parseInt(document.getElementById('testInterval').value);
            
            testStartTime = Date.now();
            document.getElementById('startStreamTest').disabled = true;
            document.getElementById('stopStreamTest').disabled = false;
            
            log(`🚀 Starting stream test: ${duration/1000}s duration, ${interval/1000}s interval`, 'info');
            
            document.getElementById('streamStatus').className = 'status warning';
            document.getElementById('streamStatus').textContent = `🔄 Stream test running...`;
            
            // Generate photos at intervals
            streamTestInterval = setInterval(() => {
                generateTestPhoto();
                
                // Update progress
                const elapsed = Date.now() - testStartTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                document.getElementById('testProgress').style.width = progress + '%';
                
            }, interval);
            
            // Stop after duration
            streamTestTimeout = setTimeout(() => {
                stopStreamTest();
            }, duration);
        }

        function stopStreamTest() {
            if (streamTestInterval) {
                clearInterval(streamTestInterval);
                streamTestInterval = null;
            }
            
            if (streamTestTimeout) {
                clearTimeout(streamTestTimeout);
                streamTestTimeout = null;
            }
            
            document.getElementById('startStreamTest').disabled = false;
            document.getElementById('stopStreamTest').disabled = true;
            document.getElementById('testProgress').style.width = '0%';
            
            document.getElementById('streamStatus').className = 'status success';
            document.getElementById('streamStatus').textContent = '✅ Stream test completed';
            
            log('🏁 Stream test completed', 'success');
        }

        function analyzeReceivedData(data, receiveTime) {
            testStats.totalReceived++;
            
            if (data.type === 'sensor_data' && data.data) {
                if (data.data.photoBase64) {
                    testStats.withPhotos++;
                    const photoSize = data.data.photoBase64.length;
                    testStats.photoSizes.push(photoSize);
                    
                    log(`📸 Received photo data: ${Math.round(photoSize / 1024)}KB`, 'success');
                    
                    // Calculate latency if we have timing info
                    if (data.data.timestamp) {
                        const sentTime = new Date(data.data.timestamp).getTime();
                        const latency = receiveTime - sentTime;
                        if (latency > 0 && latency < 60000) { // Reasonable latency range
                            testStats.latencies.push(latency);
                        }
                    }
                } else if (data.data.captureMethod === 'user_photo_capture') {
                    testStats.dataErrors++;
                    log('❌ Expected photo data missing from user photo capture', 'error');
                }
                
                // Validate data integrity
                if (!data.data.gps && !data.data.orientation && !data.data.motion && !data.data.photoBase64) {
                    testStats.dataErrors++;
                    log('❌ Received empty sensor data', 'error');
                }
            } else if (data.type === 'bulk_data_batch' && data.data) {
                log(`📦 Received bulk data batch: ${data.batchSize} items`, 'info');
                data.data.forEach(item => {
                    if (item.photoBase64) {
                        testStats.withPhotos++;
                        testStats.photoSizes.push(item.photoBase64.length);
                    }
                });
            }
        }

        // Initialize
        updateStats();
        
        // Auto-connect if URL parameter is provided
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const server = urlParams.get('server');
            if (server) {
                document.getElementById('serverUrl').value = server;
                setTimeout(testConnection, 1000);
            }
        });
    </script>
</body>
</html>